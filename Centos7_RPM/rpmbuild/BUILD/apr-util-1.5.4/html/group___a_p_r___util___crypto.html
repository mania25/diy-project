<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Portable Runtime Utility Library: Crypto routines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Portable Runtime Utility Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Crypto routines<div class="ingroups"><a class="el" href="group___a_p_r___util.html">APR Utility Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa0fd79c7b12efb93d12ed63767cfcfb0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa0fd79c7b12efb93d12ed63767cfcfb0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>APU_CRYPTO_RECOMMENDED_DRIVER</b>&#160;&#160;&#160;&quot;openssl&quot;</td></tr>
<tr class="separator:gaa0fd79c7b12efb93d12ed63767cfcfb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9185b416f007dc01079c5a7e812767ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9185b416f007dc01079c5a7e812767ab"></a>
typedef struct apr_crypto_driver_t&#160;</td><td class="memItemRight" valign="bottom"><b>apr_crypto_driver_t</b></td></tr>
<tr class="separator:ga9185b416f007dc01079c5a7e812767ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bc88e4d9f7222320c49fd874646deb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga83bc88e4d9f7222320c49fd874646deb"></a>
typedef struct apr_crypto_t&#160;</td><td class="memItemRight" valign="bottom"><b>apr_crypto_t</b></td></tr>
<tr class="separator:ga83bc88e4d9f7222320c49fd874646deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad853527ecf6bf2011f3df33d1b725ec1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad853527ecf6bf2011f3df33d1b725ec1"></a>
typedef struct apr_crypto_config_t&#160;</td><td class="memItemRight" valign="bottom"><b>apr_crypto_config_t</b></td></tr>
<tr class="separator:gad853527ecf6bf2011f3df33d1b725ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga523c9ec387ef5261b43d234f7b1a8176"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga523c9ec387ef5261b43d234f7b1a8176"></a>
typedef struct apr_crypto_key_t&#160;</td><td class="memItemRight" valign="bottom"><b>apr_crypto_key_t</b></td></tr>
<tr class="separator:ga523c9ec387ef5261b43d234f7b1a8176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac75e3dfee18a940164adc12a639c01d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac75e3dfee18a940164adc12a639c01d0"></a>
typedef struct apr_crypto_block_t&#160;</td><td class="memItemRight" valign="bottom"><b>apr_crypto_block_t</b></td></tr>
<tr class="separator:gac75e3dfee18a940164adc12a639c01d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac62c799021d3bc28449626e60351e946"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gac62c799021d3bc28449626e60351e946">apr_crypto_block_key_type_e</a> { <br/>
&#160;&#160;<b>APR_KEY_NONE</b>, 
<b>APR_KEY_3DES_192</b>, 
<a class="el" href="group___a_p_r___util___crypto.html#ggac62c799021d3bc28449626e60351e946a8c1d6aff8c24a476659f4ef074832ee6">APR_KEY_AES_128</a>, 
<a class="el" href="group___a_p_r___util___crypto.html#ggac62c799021d3bc28449626e60351e946aff350305e3e825a8b3fa0b0a6fc9804a">APR_KEY_AES_192</a>, 
<br/>
&#160;&#160;<a class="el" href="group___a_p_r___util___crypto.html#ggac62c799021d3bc28449626e60351e946add6da30b44e6546ef242b8d1d21ca9bc">APR_KEY_AES_256</a>
<br/>
 }</td></tr>
<tr class="separator:gac62c799021d3bc28449626e60351e946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad29b01edfcd38649f12d76e803dd2153"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gad29b01edfcd38649f12d76e803dd2153">apr_crypto_block_key_mode_e</a> { <b>APR_MODE_NONE</b>, 
<a class="el" href="group___a_p_r___util___crypto.html#ggad29b01edfcd38649f12d76e803dd2153af7eb194825aa815880ddef6f3ad1ce14">APR_MODE_ECB</a>, 
<a class="el" href="group___a_p_r___util___crypto.html#ggad29b01edfcd38649f12d76e803dd2153a4830062ad4c3ae50545c9b5b0ef0bc49">APR_MODE_CBC</a>
 }</td></tr>
<tr class="separator:gad29b01edfcd38649f12d76e803dd2153"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac67bd5ffd6961c27e3bccad02021edd5"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gac67bd5ffd6961c27e3bccad02021edd5">apr_crypto_init</a> (apr_pool_t *pool)</td></tr>
<tr class="memdesc:gac67bd5ffd6961c27e3bccad02021edd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform once-only initialisation. Call once only.  <a href="#gac67bd5ffd6961c27e3bccad02021edd5">More...</a><br/></td></tr>
<tr class="separator:gac67bd5ffd6961c27e3bccad02021edd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88794e872ffee43d6fefb4f13072983f"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga88794e872ffee43d6fefb4f13072983f">apr_crypto_clear</a> (apr_pool_t *pool, void *buffer, apr_size_t size)</td></tr>
<tr class="memdesc:ga88794e872ffee43d6fefb4f13072983f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a cleanup to zero out the buffer provided when the pool is cleaned up.  <a href="#ga88794e872ffee43d6fefb4f13072983f">More...</a><br/></td></tr>
<tr class="separator:ga88794e872ffee43d6fefb4f13072983f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6a35349a7e108ee4964c2d3be5f362"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga0a6a35349a7e108ee4964c2d3be5f362">apr_crypto_get_driver</a> (const apr_crypto_driver_t **driver, const char *name, const char *params, const <a class="el" href="structapu__err__t.html">apu_err_t</a> **result, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga0a6a35349a7e108ee4964c2d3be5f362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the driver struct for a name.  <a href="#ga0a6a35349a7e108ee4964c2d3be5f362">More...</a><br/></td></tr>
<tr class="separator:ga0a6a35349a7e108ee4964c2d3be5f362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cd6fef8b4b9b2d0914183a664d6e886"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga4cd6fef8b4b9b2d0914183a664d6e886">apr_crypto_driver_name</a> (const apr_crypto_driver_t *driver)</td></tr>
<tr class="memdesc:ga4cd6fef8b4b9b2d0914183a664d6e886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the driver.  <a href="#ga4cd6fef8b4b9b2d0914183a664d6e886">More...</a><br/></td></tr>
<tr class="separator:ga4cd6fef8b4b9b2d0914183a664d6e886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9795c7187a309d1710541f30b0395204"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga9795c7187a309d1710541f30b0395204">apr_crypto_error</a> (const <a class="el" href="structapu__err__t.html">apu_err_t</a> **result, const apr_crypto_t *f)</td></tr>
<tr class="memdesc:ga9795c7187a309d1710541f30b0395204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the result of the last operation on a context. If the result is NULL, the operation was successful.  <a href="#ga9795c7187a309d1710541f30b0395204">More...</a><br/></td></tr>
<tr class="separator:ga9795c7187a309d1710541f30b0395204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2232e263ef558dd93dec5bb4f010c737"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga2232e263ef558dd93dec5bb4f010c737">apr_crypto_make</a> (apr_crypto_t **f, const apr_crypto_driver_t *driver, const char *params, apr_pool_t *pool)</td></tr>
<tr class="memdesc:ga2232e263ef558dd93dec5bb4f010c737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a context for supporting encryption. Keys, certificates, algorithms and other parameters will be set per context. More than one context can be created at one time. A cleanup will be automatically registered with the given pool to guarantee a graceful shutdown.  <a href="#ga2232e263ef558dd93dec5bb4f010c737">More...</a><br/></td></tr>
<tr class="separator:ga2232e263ef558dd93dec5bb4f010c737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga784f4ab59bfab55666e9ce9fd79f7724"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga784f4ab59bfab55666e9ce9fd79f7724">apr_crypto_get_block_key_types</a> (apr_hash_t **types, const apr_crypto_t *f)</td></tr>
<tr class="memdesc:ga784f4ab59bfab55666e9ce9fd79f7724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a hash table of key types, keyed by the name of the type against an integer pointer constant.  <a href="#ga784f4ab59bfab55666e9ce9fd79f7724">More...</a><br/></td></tr>
<tr class="separator:ga784f4ab59bfab55666e9ce9fd79f7724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55368343c0e61228a941f76caf339e41"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga55368343c0e61228a941f76caf339e41">apr_crypto_get_block_key_modes</a> (apr_hash_t **modes, const apr_crypto_t *f)</td></tr>
<tr class="memdesc:ga55368343c0e61228a941f76caf339e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a hash table of key modes, keyed by the name of the mode against an integer pointer constant.  <a href="#ga55368343c0e61228a941f76caf339e41">More...</a><br/></td></tr>
<tr class="separator:ga55368343c0e61228a941f76caf339e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98dea2011c0e173ab1f059c5a9ea8b14"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga98dea2011c0e173ab1f059c5a9ea8b14">apr_crypto_passphrase</a> (apr_crypto_key_t **key, apr_size_t *ivSize, const char *pass, apr_size_t passLen, const unsigned char *salt, apr_size_t saltLen, const <a class="el" href="group___a_p_r___util___crypto.html#gac62c799021d3bc28449626e60351e946">apr_crypto_block_key_type_e</a> type, const <a class="el" href="group___a_p_r___util___crypto.html#gad29b01edfcd38649f12d76e803dd2153">apr_crypto_block_key_mode_e</a> mode, const int doPad, const int iterations, const apr_crypto_t *f, apr_pool_t *p)</td></tr>
<tr class="memdesc:ga98dea2011c0e173ab1f059c5a9ea8b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a key from the given passphrase. By default, the PBKDF2 algorithm is used to generate the key from the passphrase. It is expected that the same pass phrase will generate the same key, regardless of the backend crypto platform used. The key is cleaned up when the context is cleaned, and may be reused with multiple encryption or decryption operations.  <a href="#ga98dea2011c0e173ab1f059c5a9ea8b14">More...</a><br/></td></tr>
<tr class="separator:ga98dea2011c0e173ab1f059c5a9ea8b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga191077110391e4a8b5b97f8820bdae23"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga191077110391e4a8b5b97f8820bdae23">apr_crypto_block_encrypt_init</a> (apr_crypto_block_t **ctx, const unsigned char **iv, const apr_crypto_key_t *key, apr_size_t *blockSize, apr_pool_t *p)</td></tr>
<tr class="memdesc:ga191077110391e4a8b5b97f8820bdae23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a context for encrypting arbitrary data using the given key.  <a href="#ga191077110391e4a8b5b97f8820bdae23">More...</a><br/></td></tr>
<tr class="separator:ga191077110391e4a8b5b97f8820bdae23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98110d8923632130a39f9398170bb99a"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga98110d8923632130a39f9398170bb99a">apr_crypto_block_encrypt</a> (unsigned char **out, apr_size_t *outlen, const unsigned char *in, apr_size_t inlen, apr_crypto_block_t *ctx)</td></tr>
<tr class="memdesc:ga98110d8923632130a39f9398170bb99a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt data provided by in, write it to out.  <a href="#ga98110d8923632130a39f9398170bb99a">More...</a><br/></td></tr>
<tr class="separator:ga98110d8923632130a39f9398170bb99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02552ce92915fcd044ae9efe5b555c8b"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga02552ce92915fcd044ae9efe5b555c8b">apr_crypto_block_encrypt_finish</a> (unsigned char *out, apr_size_t *outlen, apr_crypto_block_t *ctx)</td></tr>
<tr class="memdesc:ga02552ce92915fcd044ae9efe5b555c8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encrypt final data block, write it to out.  <a href="#ga02552ce92915fcd044ae9efe5b555c8b">More...</a><br/></td></tr>
<tr class="separator:ga02552ce92915fcd044ae9efe5b555c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab24c68f757f14a4369ef6c79a04ab8c4"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gab24c68f757f14a4369ef6c79a04ab8c4">apr_crypto_block_decrypt_init</a> (apr_crypto_block_t **ctx, apr_size_t *blockSize, const unsigned char *iv, const apr_crypto_key_t *key, apr_pool_t *p)</td></tr>
<tr class="memdesc:gab24c68f757f14a4369ef6c79a04ab8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a context for decrypting arbitrary data using the given key.  <a href="#gab24c68f757f14a4369ef6c79a04ab8c4">More...</a><br/></td></tr>
<tr class="separator:gab24c68f757f14a4369ef6c79a04ab8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82e6b7f5768952464aa4b0af481de0c"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gaf82e6b7f5768952464aa4b0af481de0c">apr_crypto_block_decrypt</a> (unsigned char **out, apr_size_t *outlen, const unsigned char *in, apr_size_t inlen, apr_crypto_block_t *ctx)</td></tr>
<tr class="memdesc:gaf82e6b7f5768952464aa4b0af481de0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt data provided by in, write it to out.  <a href="#gaf82e6b7f5768952464aa4b0af481de0c">More...</a><br/></td></tr>
<tr class="separator:gaf82e6b7f5768952464aa4b0af481de0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13a4f1d70437f6722018006d3dde42d"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#gac13a4f1d70437f6722018006d3dde42d">apr_crypto_block_decrypt_finish</a> (unsigned char *out, apr_size_t *outlen, apr_crypto_block_t *ctx)</td></tr>
<tr class="memdesc:gac13a4f1d70437f6722018006d3dde42d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrypt final data block, write it to out.  <a href="#gac13a4f1d70437f6722018006d3dde42d">More...</a><br/></td></tr>
<tr class="separator:gac13a4f1d70437f6722018006d3dde42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f351ebb6527dd32604de58d5199846d"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga0f351ebb6527dd32604de58d5199846d">apr_crypto_block_cleanup</a> (apr_crypto_block_t *ctx)</td></tr>
<tr class="memdesc:ga0f351ebb6527dd32604de58d5199846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean encryption / decryption context.  <a href="#ga0f351ebb6527dd32604de58d5199846d">More...</a><br/></td></tr>
<tr class="separator:ga0f351ebb6527dd32604de58d5199846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39bf6b81c4f4cef03915029eb3266cc2"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga39bf6b81c4f4cef03915029eb3266cc2">apr_crypto_cleanup</a> (apr_crypto_t *f)</td></tr>
<tr class="memdesc:ga39bf6b81c4f4cef03915029eb3266cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean encryption / decryption context.  <a href="#ga39bf6b81c4f4cef03915029eb3266cc2">More...</a><br/></td></tr>
<tr class="separator:ga39bf6b81c4f4cef03915029eb3266cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748292b8c676934763237bd062d094b9"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___crypto.html#ga748292b8c676934763237bd062d094b9">apr_crypto_shutdown</a> (const apr_crypto_driver_t *driver)</td></tr>
<tr class="memdesc:ga748292b8c676934763237bd062d094b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shutdown the crypto library.  <a href="#ga748292b8c676934763237bd062d094b9">More...</a><br/></td></tr>
<tr class="separator:ga748292b8c676934763237bd062d094b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gad29b01edfcd38649f12d76e803dd2153"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_p_r___util___crypto.html#gad29b01edfcd38649f12d76e803dd2153">apr_crypto_block_key_mode_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggad29b01edfcd38649f12d76e803dd2153af7eb194825aa815880ddef6f3ad1ce14"></a>APR_MODE_ECB</em>&nbsp;</td><td class="fielddoc">
<p>An error condition </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggad29b01edfcd38649f12d76e803dd2153a4830062ad4c3ae50545c9b5b0ef0bc49"></a>APR_MODE_CBC</em>&nbsp;</td><td class="fielddoc">
<p>Electronic Code Book Cipher Block Chaining </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gac62c799021d3bc28449626e60351e946"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_p_r___util___crypto.html#gac62c799021d3bc28449626e60351e946">apr_crypto_block_key_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symmetric Key types understood by the library.</p>
<p>NOTE: It is expected that this list will grow over time.</p>
<p>Interoperability Matrix:</p>
<p>The matrix is based on the testcrypto.c unit test, which attempts to test whether a simple encrypt/decrypt will succeed, as well as testing whether an encrypted string by one library can be decrypted by the others.</p>
<p>Some libraries will successfully encrypt and decrypt their own data, but won't decrypt data from another library. It is hoped that over time these anomalies will be found and fixed, but until then it is recommended that ciphers are chosen that interoperate across platform.</p>
<p>An X below means the test passes, it does not necessarily mean that encryption performed is correct or secure. Applications should stick to ciphers that pass the interoperablity tests on the right hand side of the table.</p>
<p>Aligned data is data whose length is a multiple of the block size for the chosen cipher. Padded data is data that is not aligned by block size and must be padded by the crypto library. </p>
<pre class="fragment">             OpenSSL      NSS      Interop
            Align Pad  Align Pad  Align Pad
</pre><p> 3DES_192/CBC X X X X X X 3DES_192/ECB X X AES_256/CBC X X X X X X AES_256/ECB X X X X AES_192/CBC X X X X AES_192/ECB X X X AES_128/CBC X X X X AES_128/ECB X X X</p>
<p>Conclusion: for padded data, use 3DES_192/CBC or AES_256/CBC. For aligned data, use 3DES_192/CBC, AES_256/CBC or AES_256/ECB. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggac62c799021d3bc28449626e60351e946a8c1d6aff8c24a476659f4ef074832ee6"></a>APR_KEY_AES_128</em>&nbsp;</td><td class="fielddoc">
<p>192 bit (3-Key) 3DES </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac62c799021d3bc28449626e60351e946aff350305e3e825a8b3fa0b0a6fc9804a"></a>APR_KEY_AES_192</em>&nbsp;</td><td class="fielddoc">
<p>128 bit AES </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggac62c799021d3bc28449626e60351e946add6da30b44e6546ef242b8d1d21ca9bc"></a>APR_KEY_AES_256</em>&nbsp;</td><td class="fielddoc">
<p>192 bit AES 256 bit AES </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga0f351ebb6527dd32604de58d5199846d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_cleanup </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_block_t *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean encryption / decryption context. </p>
<dl class="section note"><dt>Note</dt><dd>After cleanup, a context is free to be reused if necessary. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The block context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOTIMPL if not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf82e6b7f5768952464aa4b0af481de0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_decrypt </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_crypto_block_t *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt data provided by in, write it to out. </p>
<dl class="section note"><dt>Note</dt><dd>The number of bytes written will be written to outlen. If out is NULL, outlen will contain the maximum size of the buffer needed to hold the data, including any data generated by apr_crypto_block_decrypt_finish below. If *out points to NULL, a buffer sufficiently large will be created from the pool provided. If *out points to a not-NULL value, this value will be used as a buffer instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Address of a buffer to which data will be written, see note. </td></tr>
    <tr><td class="paramname">outlen</td><td>Length of the output will be written here. </td></tr>
    <tr><td class="paramname">in</td><td>Address of the buffer to read. </td></tr>
    <tr><td class="paramname">inlen</td><td>Length of the buffer to read. </td></tr>
    <tr><td class="paramname">ctx</td><td>The block context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="gac13a4f1d70437f6722018006d3dde42d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_decrypt_finish </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_crypto_block_t *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrypt final data block, write it to out. </p>
<dl class="section note"><dt>Note</dt><dd>If necessary the final block will be written out after being padded. Typically the final block will be written to the same buffer used by apr_crypto_block_decrypt, offset by the number of bytes returned as actually written by the <a class="el" href="group___a_p_r___util___crypto.html#gaf82e6b7f5768952464aa4b0af481de0c" title="Decrypt data provided by in, write it to out. ">apr_crypto_block_decrypt()</a> call. After this call, the context is cleaned and can be reused by <a class="el" href="group___a_p_r___util___crypto.html#gab24c68f757f14a4369ef6c79a04ab8c4" title="Initialise a context for decrypting arbitrary data using the given key. ">apr_crypto_block_decrypt_init()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Address of a buffer to which data will be written. This buffer must already exist, and is usually the same buffer used by apr_evp_crypt(). See note. </td></tr>
    <tr><td class="paramname">outlen</td><td>Length of the output will be written here. </td></tr>
    <tr><td class="paramname">ctx</td><td>The block context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ECRYPT if an error occurred. </dd>
<dd>
APR_EPADDING if padding was enabled and the block was incorrectly formatted. </dd>
<dd>
APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="gab24c68f757f14a4369ef6c79a04ab8c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_decrypt_init </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_block_t **&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_key_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a context for decrypting arbitrary data using the given key. </p>
<dl class="section note"><dt>Note</dt><dd>If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If *ctx is not NULL, *ctx must point at a previously created structure. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The block context returned, see note. </td></tr>
    <tr><td class="paramname">blockSize</td><td>The block size of the cipher. </td></tr>
    <tr><td class="paramname">iv</td><td>Optional initialisation vector. </td></tr>
    <tr><td class="paramname">key</td><td>The key structure to use. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOIV if an initialisation vector is required but not specified. Returns APR_EINIT if the backend failed to initialise the context. Returns APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98110d8923632130a39f9398170bb99a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_encrypt </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>inlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_crypto_block_t *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt data provided by in, write it to out. </p>
<dl class="section note"><dt>Note</dt><dd>The number of bytes written will be written to outlen. If out is NULL, outlen will contain the maximum size of the buffer needed to hold the data, including any data generated by apr_crypto_block_encrypt_finish below. If *out points to NULL, a buffer sufficiently large will be created from the pool provided. If *out points to a not-NULL value, this value will be used as a buffer instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Address of a buffer to which data will be written, see note. </td></tr>
    <tr><td class="paramname">outlen</td><td>Length of the output will be written here. </td></tr>
    <tr><td class="paramname">in</td><td>Address of the buffer to read. </td></tr>
    <tr><td class="paramname">inlen</td><td>Length of the buffer to read. </td></tr>
    <tr><td class="paramname">ctx</td><td>The block context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ECRYPT if an error occurred. Returns APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga02552ce92915fcd044ae9efe5b555c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_encrypt_finish </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>outlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_crypto_block_t *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encrypt final data block, write it to out. </p>
<dl class="section note"><dt>Note</dt><dd>If necessary the final block will be written out after being padded. Typically the final block will be written to the same buffer used by apr_crypto_block_encrypt, offset by the number of bytes returned as actually written by the <a class="el" href="group___a_p_r___util___crypto.html#ga98110d8923632130a39f9398170bb99a" title="Encrypt data provided by in, write it to out. ">apr_crypto_block_encrypt()</a> call. After this call, the context is cleaned and can be reused by <a class="el" href="group___a_p_r___util___crypto.html#ga191077110391e4a8b5b97f8820bdae23" title="Initialise a context for encrypting arbitrary data using the given key. ">apr_crypto_block_encrypt_init()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>Address of a buffer to which data will be written. This buffer must already exist, and is usually the same buffer used by apr_evp_crypt(). See note. </td></tr>
    <tr><td class="paramname">outlen</td><td>Length of the output will be written here. </td></tr>
    <tr><td class="paramname">ctx</td><td>The block context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ECRYPT if an error occurred. </dd>
<dd>
APR_EPADDING if padding was enabled and the block was incorrectly formatted. </dd>
<dd>
APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga191077110391e4a8b5b97f8820bdae23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_block_encrypt_init </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_block_t **&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char **&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_key_t *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a context for encrypting arbitrary data using the given key. </p>
<dl class="section note"><dt>Note</dt><dd>If *ctx is NULL, a apr_crypto_block_t will be created from a pool. If *ctx is not NULL, *ctx must point at a previously created structure. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The block context returned, see note. </td></tr>
    <tr><td class="paramname">iv</td><td>Optional initialisation vector. If the buffer pointed to is NULL, an IV will be created at random, in space allocated from the pool. If the buffer pointed to is not NULL, the IV in the buffer will be used. </td></tr>
    <tr><td class="paramname">key</td><td>The key structure to use. </td></tr>
    <tr><td class="paramname">blockSize</td><td>The block size of the cipher. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOIV if an initialisation vector is required but not specified. Returns APR_EINIT if the backend failed to initialise the context. Returns APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga39bf6b81c4f4cef03915029eb3266cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_cleanup </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_t *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean encryption / decryption context. </p>
<dl class="section note"><dt>Note</dt><dd>After cleanup, a context is free to be reused if necessary. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The context to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOTIMPL if not supported. </dd></dl>

</div>
</div>
<a class="anchor" id="ga88794e872ffee43d6fefb4f13072983f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_clear </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a cleanup to zero out the buffer provided when the pool is cleaned up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>- pool to register the cleanup </td></tr>
    <tr><td class="paramname">buffer</td><td>- buffer to zero out </td></tr>
    <tr><td class="paramname">size</td><td>- size of the buffer to zero out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4cd6fef8b4b9b2d0914183a664d6e886"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* apr_crypto_driver_name </td>
          <td>(</td>
          <td class="paramtype">const apr_crypto_driver_t *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>- The driver in use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the driver. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9795c7187a309d1710541f30b0395204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structapu__err__t.html">apu_err_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_t *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the result of the last operation on a context. If the result is NULL, the operation was successful. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>- the result structure </td></tr>
    <tr><td class="paramname">f</td><td>- context pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga55368343c0e61228a941f76caf339e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_get_block_key_modes </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>modes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_t *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a hash table of key modes, keyed by the name of the mode against an integer pointer constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">modes</td><td>- hashtable of key modes keyed to constants. </td></tr>
    <tr><td class="paramname">f</td><td>- encryption context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga784f4ab59bfab55666e9ce9fd79f7724"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_get_block_key_types </td>
          <td>(</td>
          <td class="paramtype">apr_hash_t **&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_t *&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a hash table of key types, keyed by the name of the type against an integer pointer constant. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">types</td><td>- hashtable of key types keyed to constants. </td></tr>
    <tr><td class="paramname">f</td><td>- encryption context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS for success </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a6a35349a7e108ee4964c2d3be5f362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_get_driver </td>
          <td>(</td>
          <td class="paramtype">const apr_crypto_driver_t **&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structapu__err__t.html">apu_err_t</a> **&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the driver struct for a name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>- pointer to driver struct. </td></tr>
    <tr><td class="paramname">name</td><td>- driver name </td></tr>
    <tr><td class="paramname">params</td><td>- array of initialisation parameters </td></tr>
    <tr><td class="paramname">result</td><td>- result and error message on failure </td></tr>
    <tr><td class="paramname">pool</td><td>- (process) pool to register cleanup </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS for success </dd>
<dd>
APR_ENOTIMPL for no driver (when DSO not enabled) </dd>
<dd>
APR_EDSOOPEN if DSO driver file can't be opened </dd>
<dd>
APR_ESYMNOTFOUND if the driver file doesn't contain a driver </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>NSS: the params can have "dir", "key3", "cert7" and "secmod" keys, each followed by an equal sign and a value. Such key/value pairs can be delimited by space or tab. If the value contains a space, surround the whole key value pair in quotes: "dir=My Directory". </dd>
<dd>
OpenSSL: currently no params are supported. </dd></dl>

</div>
</div>
<a class="anchor" id="gac67bd5ffd6961c27e3bccad02021edd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_init </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform once-only initialisation. Call once only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pool</td><td>- pool to register any shutdown cleanups, etc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_NOTIMPL in case of no crypto support. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2232e263ef558dd93dec5bb4f010c737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_make </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_t **&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_driver_t *&#160;</td>
          <td class="paramname"><em>driver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a context for supporting encryption. Keys, certificates, algorithms and other parameters will be set per context. More than one context can be created at one time. A cleanup will be automatically registered with the given pool to guarantee a graceful shutdown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- context pointer will be written here </td></tr>
    <tr><td class="paramname">driver</td><td>- driver to use </td></tr>
    <tr><td class="paramname">params</td><td>- array of key parameters </td></tr>
    <tr><td class="paramname">pool</td><td>- process pool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOENGINE when the engine specified does not exist. APR_EINITENGINE if the engine cannot be initialised. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>NSS: currently no params are supported. </dd>
<dd>
OpenSSL: the params can have "engine" as a key, followed by an equal sign and a value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga98dea2011c0e173ab1f059c5a9ea8b14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_passphrase </td>
          <td>(</td>
          <td class="paramtype">apr_crypto_key_t **&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>ivSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>passLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>salt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>saltLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_p_r___util___crypto.html#gac62c799021d3bc28449626e60351e946">apr_crypto_block_key_type_e</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___a_p_r___util___crypto.html#gad29b01edfcd38649f12d76e803dd2153">apr_crypto_block_key_mode_e</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>doPad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const apr_crypto_t *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a key from the given passphrase. By default, the PBKDF2 algorithm is used to generate the key from the passphrase. It is expected that the same pass phrase will generate the same key, regardless of the backend crypto platform used. The key is cleaned up when the context is cleaned, and may be reused with multiple encryption or decryption operations. </p>
<dl class="section note"><dt>Note</dt><dd>If *key is NULL, a apr_crypto_key_t will be created from a pool. If *key is not NULL, *key must point at a previously created structure. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key returned, see note. </td></tr>
    <tr><td class="paramname">ivSize</td><td>The size of the initialisation vector will be returned, based on whether an IV is relevant for this type of crypto. </td></tr>
    <tr><td class="paramname">pass</td><td>The passphrase to use. </td></tr>
    <tr><td class="paramname">passLen</td><td>The passphrase length in bytes </td></tr>
    <tr><td class="paramname">salt</td><td>The salt to use. </td></tr>
    <tr><td class="paramname">saltLen</td><td>The salt length in bytes </td></tr>
    <tr><td class="paramname">type</td><td>3DES_192, AES_128, AES_192, AES_256. </td></tr>
    <tr><td class="paramname">mode</td><td>Electronic Code Book / Cipher Block Chaining. </td></tr>
    <tr><td class="paramname">doPad</td><td>Pad if necessary. </td></tr>
    <tr><td class="paramname">iterations</td><td>Number of iterations to use in algorithm </td></tr>
    <tr><td class="paramname">f</td><td>The context to use. </td></tr>
    <tr><td class="paramname">p</td><td>The pool to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOKEY if the pass phrase is missing or empty, or if a backend error occurred while generating the key. APR_ENOCIPHER if the type or mode is not supported by the particular backend. APR_EKEYTYPE if the key type is not known. APR_EPADDING if padding was requested but is not supported. APR_ENOTIMPL if not implemented. </dd></dl>

</div>
</div>
<a class="anchor" id="ga748292b8c676934763237bd062d094b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_crypto_shutdown </td>
          <td>(</td>
          <td class="paramtype">const apr_crypto_driver_t *&#160;</td>
          <td class="paramname"><em>driver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shutdown the crypto library. </p>
<dl class="section note"><dt>Note</dt><dd>After shutdown, it is expected that the init function can be called again. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">driver</td><td>- driver to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns APR_ENOTIMPL if not supported. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
